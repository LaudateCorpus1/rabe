//! This is the documentation for the `LSW` scheme:
//!
//! * Developped by Allison Lewko, Amit Sahai and Brent Waters, "Revocation Systems with Very Small Private Keys"
//! * Published in Security and Privacy, 2010. SP'10. IEEE Symposium on. IEEE
//! * Available from http://eprint.iacr.org/2008/309.pdf
//! * Type: encryption (key-policy attribute-based)
//! * Setting: bilinear groups (asymmetric)
//! * Authors: Georg Bramm
//! * Date:	04/2018
//!
//! # Examples
//!
//! ```
//!use rabe::schemes::lsw::*;
//!use rabe::utils::policy::pest::PolicyLanguage;
//!let (pk, msk) = setup();
//!let plaintext = String::from("our plaintext!").into_bytes();
//!let policy = String::from(r#""X" or "B""#);
//!let ct_kp: KpAbeCiphertext = encrypt(&pk, &vec!["A".to_string(), "B".to_string()], &plaintext).unwrap();
//!let sk: KpAbeSecretKey = keygen(&pk, &msk, &policy, PolicyLanguage::HumanPolicy).unwrap();
//!assert_eq!(decrypt(&sk, &ct_kp).unwrap(), plaintext);
//! ```
use rabe_bn::{Fr, G1, G2, Gt, pairing};
use utils::{
    aes::*,
    hash::{blake2b_hash_fr, blake2b_hash_g1}
};
use rand::Rng;

/// A LSW Public Key (PK)
#[derive(PartialEq, Clone)]
pub struct KpAbePublicKey {
    _g_g1: G1,
    _g_g2: G2,
    _g_g1_b: G1,
    _g_g1_b2: G1,
    _h_g1_b: G1,
    _e_gg_alpha: Gt,
}

/// A LSW Master Key (MSK)
#[derive(PartialEq, Clone)]
pub struct KpAbeMasterKey {
    _alpha1: Fr,
    _alpha2: Fr,
    _beta: Fr,
    _h_g1: G1,
    _h_g2: G2,
}

/// A LSW Ciphertext (CT)
#[derive(PartialEq, Clone)]
pub struct KpAbeCiphertext {
    _e1: Gt,
    _e2: G2,
    _ej: Vec<(String, G1, G1, G1)>,
    _ct: Vec<u8>,
}

/// The setup algorithm of LSW KP-ABE. Generates a new KpAbePublicKey and a new KpAbeMasterKey.
pub fn setup() -> (KpAbePublicKey, KpAbeMasterKey) {
    // random number generator
    let mut _rng = rand::thread_rng();
    // generate random alpha1, alpha2 and b
    let _alpha1:Fr = _rng.gen();
    let _alpha2:Fr = _rng.gen();
    let _beta:Fr = _rng.gen();
    let _alpha = _alpha1 * _alpha2;
    let _g_g1:G1 = _rng.gen();
    let _g_g2:G2 = _rng.gen();
    let _h_g1:G1 = _rng.gen();
    let _h_g2:G2 = _rng.gen();
    let _g_g1_b = _g_g1 * _beta;
    let _g_g1_b2 = _g_g1_b * _beta;
    let _h_g1_b = _h_g1 * _beta;
    // calculate the pairing between g1 and g2^alpha
    let _e_gg_alpha = pairing(_g_g1, _g_g2).pow(_alpha);
    // return PK and MSK
    return (
        KpAbePublicKey { _g_g1, _g_g2, _g_g1_b, _g_g1_b2, _h_g1_b, _e_gg_alpha},
        KpAbeMasterKey {_alpha1, _alpha2, _beta, _h_g1, _h_g2}
    );
}

/// The encrypt algorithm of LSW KP-ABE. Generates a new KpAbeCiphertext using an KpAbePublicKey, a set of attributes given as String Vector and some plaintext data given as [u8].
///
/// # Arguments
///
///	* `_pk` - A Public Key (PK), generated by the function setup()
///	* `_attributes` - A set of attributes given as String Vector
///	* `_plaintext` - plaintext data given as a Vector of u8
///
pub fn encrypt(
    _pk: &KpAbePublicKey,
    _attributes: &Vec<String>,
    _plaintext: &[u8],
) -> Option<KpAbeCiphertext> {
    if _attributes.is_empty() || _plaintext.is_empty() {
        return None;
    } else {
        // random number generator
        let mut _rng = rand::thread_rng();
        // attribute vector
        let mut _ej: Vec<(String, G1, G1, G1)> = Vec::new();
        // random secret
        let _s:Fr = _rng.gen();
        // sx vector
        let mut _sx: Vec<Fr> = Vec::new();
        _sx.push(_s);
        for (_i, _attr) in _attributes.iter().enumerate() {
            _sx.push(_rng.gen());
            _sx[0] = _sx[0] - _sx[_i];
        }
        for (_i, _attr) in _attributes.into_iter().enumerate() {
            _ej.push((
                _attr.to_string(),
                blake2b_hash_g1(_pk._g_g1, &_attr) * _s,
                _pk._g_g1_b * _sx[_i],
                (_pk._g_g1_b2 * (_sx[_i] * blake2b_hash_fr(&_attr))) + (_pk._h_g1_b * _sx[_i]),
            ));
        }
        // random message
        let _msg: Gt = _rng.gen();
        let _e1 = _pk._e_gg_alpha.pow(_s) * _msg;
        let _e2 = _pk._g_g2 * _s;
        let _ct = encrypt_symmetric(&_msg, &_plaintext.to_vec()).unwrap();
        //Encrypt plaintext using derived key from secret
        Some(KpAbeCiphertext {_e1, _e2, _ej, _ct})
    }
}

fn is_negative(_attr: &String) -> bool {
    let first_char = &_attr[..1];
    return first_char == '!'.to_string();
}


#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn and() {
        // setup scheme
        let (pk, msk) = setup();
        // a set of two attributes matching the policy
        let mut att_matching: Vec<String> = Vec::new();
        att_matching.push(String::from("A"));
        att_matching.push(String::from("B"));
        att_matching.push(String::from("C"));
        // our plaintext
        let plaintext =
            String::from("dance like no one's watching, encrypt like everyone is!").into_bytes();
        // our policy
        let policy = String::from(r#"{"name": "and", "children": [{"name": "C"}, {"name": "B"}]}"#);
        // kp-abe ciphertext
        let ct_kp_matching: KpAbeCiphertext = encrypt(&pk, &att_matching, &plaintext).unwrap();
        // a kp-abe SK key
        let sk: KpAbeSecretKey = keygen(&pk, &msk, &policy, PolicyLanguage::JsonPolicy).unwrap();
        // and now decrypt again with matching sk
        assert_eq!(decrypt(&sk, &ct_kp_matching).unwrap(), plaintext);
    }

    #[test]
    fn or() {
        // setup scheme
        let (pk, msk) = setup();
        // a set of two attributes matching the policy
        let mut att_matching: Vec<String> = Vec::new();
        att_matching.push(String::from("A"));
        att_matching.push(String::from("B"));
        att_matching.push(String::from("C"));
        // our plaintext
        let plaintext =
            String::from("dance like no one's watching, encrypt like everyone is!").into_bytes();
        // our policy
        let policy = String::from(r#"{"name": "or", "children": [{"name": "X"}, {"name": "B"}]}"#);
        // kp-abe ciphertext
        let ct_kp_matching: KpAbeCiphertext = encrypt(&pk, &att_matching, &plaintext).unwrap();
        // a kp-abe SK key
        let sk: KpAbeSecretKey = keygen(&pk, &msk, &policy, PolicyLanguage::JsonPolicy).unwrap();
        // and now decrypt again with matching sk
        assert_eq!(decrypt(&sk, &ct_kp_matching).unwrap(), plaintext);
    }

    #[test]
    fn or_and() {
        // setup scheme
        let (pk, msk) = setup();
        // a set of two attributes matching the policy
        let mut att_matching: Vec<String> = Vec::new();
        att_matching.push(String::from("A"));
        att_matching.push(String::from("Y"));
        att_matching.push(String::from("Z"));
        // our plaintext
        let plaintext =
            String::from("dance like no one's watching, encrypt like everyone is!").into_bytes();
        // our policy
        let policy =
            String::from(r#"{"name": "or", "children": [{"name": "X"}, {"name": "and", "children": [{"name": "Y"}, {"name": "Z"}]}]}"#);
        // kp-abe ciphertext
        let ct_kp_matching: KpAbeCiphertext = encrypt(&pk, &att_matching, &plaintext).unwrap();
        // a kp-abe SK key
        let sk: KpAbeSecretKey = keygen(&pk, &msk, &policy, PolicyLanguage::JsonPolicy).unwrap();
        // and now decrypt again with matching sk
        assert_eq!(decrypt(&sk, &ct_kp_matching).unwrap(), plaintext);
    }

    #[test]
    fn not() {
        // setup scheme
        let (pk, msk) = setup();
        // a set of two attributes matching the policy
        let mut att_matching: Vec<String> = Vec::new();
        att_matching.push(String::from("A"));
        att_matching.push(String::from("B"));
        // our plaintext
        let plaintext =
            String::from("dance like no one's watching, encrypt like everyone is!").into_bytes();
        // our policy
        let policy = String::from(r#"{"name": "or", "children": [{"name": "X"}, {"name": "Y"}]}"#);
        // kp-abe ciphertext
        let ct_kp_matching: KpAbeCiphertext = encrypt(&pk, &att_matching, &plaintext).unwrap();
        // a kp-abe SK key
        let sk: KpAbeSecretKey = keygen(&pk, &msk, &policy, PolicyLanguage::JsonPolicy).unwrap();
        // and now decrypt again with matching sk
        let res = decrypt(&sk, &ct_kp_matching);
        assert_eq!(res.is_ok(), false);
    }
}
